// Copyright (c) Open Enclave SDK contributors.
// Licensed under the MIT License.

#include <stdio.h>

#include <openenclave/host.h>

// Include the untrusted EnclaveFibonacci header that is generated
// during the build. This file is generated by calling the
// SDK's oeedger8r tool against the EnclaveFibonacci.edl file.
#include "ConfidentialPackageSpecification_u.h"

static oe_enclave_t* g_enclave = NULL;

// This is the function that the enclave will call back into to print a message.
int ocall_log(char* msg)
{
    if (printf("Enclave called into host to print: %s\n", msg)) {
        return 1;
    }

    return 0;
}

int create_enclave(int argc, const char* argv[])
{
    oe_result_t result = OE_OK;
    uint32_t flags = 0;


    // Create the enclave.
    result = oe_create_ConfidentialPackageSpecification_enclave(
        "d3c5bbbc-adad-11eb-bd25-4362002e2749", 
        OE_ENCLAVE_TYPE_AUTO, 
        flags,
        NULL, 
        0,
        &g_enclave);
    if (result != OE_OK)
    {
        printf("oe_create_enclave(): result=%u (%s)\n", result, oe_result_str(result));
        return 1;
    }

    return 0;
}


int terminate_enclave()
{
    oe_result_t result;

    // Clean up the enclave if we created one.
    if (g_enclave)
    {
        result = oe_terminate_enclave(g_enclave);
        if (result != OE_OK)
        {
            printf("calling into oe_terminate_enclave failed: result=%u (%s)\n", result, oe_result_str(result));
            return 1;
        }
    }

    return 0;
}


int test_ecall_ping(void)
{
    
    int host_result;
    oe_result_t result;
    
    
    unsigned int supported_contract_version;
    
    result = ecall_ping(g_enclave, &host_result, &supported_contract_version);
    if (result != OE_OK)
    {
        printf("calling into ecall_ping failed: result=%u (%s)\n", result, oe_result_str(result));
        return 1;
    }
    else if (host_result != 0)
    {
        printf("ecall_ping failed: result=%u\n", host_result);
        return 1;
    }
    printf("Supported supported_contract_version = %i\n", supported_contract_version);
    
}


int test_ecall_supportedOperations(void) {
    
    char supportedOperations[][48] = {
        "ecall_ping",
        "ecall_is_operation_supported",
        "ecall_get_device_public_key_data_size",
        "ecall_export_device_public_key",
        "ecall_install_application_key",
        "ecall_begin_application_deployment",
        "ecall_initialize_decryption_aes_gcm",
        "ecall_add_application_data",
        "ecall_verify_application_sha256_rsa_pkcs1_v15",
        "ecall_end_application_deployment",
        "known upsupported command",
    };
    
    int i;
    int nof_operations;
    int host_result;
    oe_result_t result;
    bool supported = false;
    
    nof_operations = (sizeof(supportedOperations) / sizeof(supportedOperations[0]));
    
    for (i = 0; i < nof_operations; i++) {
         result = ecall_is_operation_supported(g_enclave, &host_result, supportedOperations[i], &supported);
        if (result != OE_OK)
        {
            printf("calling into ecall_is_operation_supported failed: result=%u (%s)\n", result, oe_result_str(result));
            return 1;
        }
        else if (host_result != 0)
        {
            printf("ecall_is_operation_supported failed: result=%u\n", host_result);
            return 1;
        }
        printf("Command %48s : %i\n", supportedOperations[i], supported);
        
    }
}


int test_ecall_get_device_public_key_data_size(void) 
{
    int host_result;
    oe_result_t result;
    
    
    unsigned int pub_key_size;
    
    result = ecall_get_device_public_key_data_size(g_enclave, &host_result, &pub_key_size);
    if (result != OE_OK)
    {
        printf("calling into test_ecall_get_device_public_key_data_size failed: result=%u (%s)\n", result, oe_result_str(result));
        return -1;
    }
    else if (host_result != 0)
    {
        printf("test_ecall_get_device_public_key_data_size failed: result=%u\n", host_result);
        return -2;
    }
    printf("Public key size = %i (0x%x)\n", pub_key_size, pub_key_size);    
    
    return pub_key_size;
}


int test_ecall_export_device_public_key(int pub_key_size) 
{
    int host_result;
    oe_result_t result;
    int i;
    
    unsigned char *pub_key;
    
    pub_key = malloc(pub_key_size);
    
    result = ecall_export_device_public_key(g_enclave, &host_result, pub_key, pub_key_size);
    if (result != OE_OK)
    {
        printf("calling into ecall_export_device_public_key failed: result=%i (%s)\n", result, oe_result_str(result));
        return 1;
    }
    else if (host_result != 0)
    {
        printf("ecall_export_device_public_key failed: result=%i\n", host_result);
        return 1;
    }
    
    for (i = 0; i < pub_key_size; i++) {
        if ((i % 16) == 0) printf("[%03x] ", i);
        printf("%02x", pub_key[i]);
        if ( (i % 4) == 3) printf(" ");
        if ((i % 16) == 15) printf("\n");
    }
    printf("\n");
}


int cpk_run_tests()
{
    printf("-------------------------------------\n");
    test_ecall_ping();
    printf("-------------------------------------\n");
    test_ecall_supportedOperations();
    printf("-------------------------------------\n");
    test_ecall_export_device_public_key(
        test_ecall_get_device_public_key_data_size()
    );
    printf("-------------------------------------\n");
    
}
